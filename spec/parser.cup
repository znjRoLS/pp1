

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_01_import.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package rosko.bojan;

import java_cup.runtime.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;

import rosko.bojan.SymbolCounter;
import rosko.bojan.SemanticContext.SemanticSymbol.*;
import rosko.bojan.SemanticContext.SemanticSymbol;
import rosko.bojan.SemanticContext.SemanticParameters;

import rosko.bojan.ExpressionToken;

import java.util.HashMap;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_02_parser_code.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

parser code {:
    Logger logger = LogManager.getLogger(Parser.class);
    Scanner scanner;
    Symbol currSym;
    Boolean errorDetected;

    public SemanticContext context = new SemanticContext(this);

    void report_error(String msg) {
        errorDetected = true;
        logger.error(msg);
        //System.err.println("ERROR: " + msg);
    }
    void report_info(String msg) {
        logger.info(msg);
        //System.err.println("INFO: " + msg);
    }
    void report_debug(String msg) {
        logger.debug(msg);
        //System.err.println("INFO: " + msg);
    }
    void dump() {
        context.dumpTable();
    }

    public static String printExpr(ExpressionToken expr) {
        if (expr == null) return null;
        return "type: " + printObjKind(expr.objType.getKind()) + ", val: " + (expr.isVar?"lvalue":"rvalue");
    }

    public static String printObj(Obj object){
        return "name: " + object.getName() +
                ", type: " + printObjKind(object.getType().getKind()) +
                ", kind: " + printObjType(object.getKind());
    }

    public static String printObjType(int type) {
            // public static final int Con = 0, Var = 1, Type = 2, Meth = 3, Fld = 4, Elem=5, Prog = 6;
            final HashMap<Integer, String> typeMap = new HashMap<Integer, String>() {
                {
                    put(0, "Con");
                    put(1, "Var");
                    put(2, "Type");
                    put(3, "Meth");
                    put(4, "Fld");
                    put(5, "Elem");
                    put(6, "Prog");
                }
            };

            return typeMap.get(type);
        }

        public static String printObjKind(int type) {
            // kodiranje tipova
            // public static final int None = 0;
            // public static final int Int = 1;
            // public static final int Char = 2;
            // public static final int Array = 3;
            // public static final int Class = 4;
            // public static final int Bool = 5;
            final HashMap<Integer, String> typeMap = new HashMap<Integer, String>() {
                {
                    put(0, "None");
                    put(1, "Int");
                    put(2, "Char");
                    put(3, "Array");
                    put(4, "Class");
                    put(5, "Bool");
                }
            };

            return typeMap.get(type);

        }

:}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_03_scan_code.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

scan with {:
    currSym = scanner.next_token();
    if (currSym != null && currSym.value != null) {
        report_info("Parsed symbol: " + currSym.value + " - " + currSym);
    }
    return currSym;
:}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_04_init_code.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

init with {:
    errorDetected = false;
    scanner = this.getScanner();
    Tab.init();

    Obj voidObj = Tab.insert(Obj.Type, "void", new Struct(Struct.None));
    Obj boolObj = Tab.insert(Obj.Type, "bool", new Struct(Struct.Bool));

    voidObj.setAdr(-1);
    boolObj.setAdr(-1);
    voidObj.setLevel(-1);
    boolObj.setLevel(-1);

    action_obj.ctx = context;
:}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_05_action_code.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

action code {:

    enum ValueType {
        LVALUE,
        RVALUE
    }

    final Pair<Integer, ValueType> EMPTY_VALUE = new Pair<Integer, ValueType>(-1, ValueType.RVALUE);

    Obj currentMethod = null;
    Struct currentVarDeclType;

    SemanticContext ctx;


    void report_error(String msg) {
        this.parser.report_error(msg);
        //System.err.println("ERROR: " + msg);
    }
    void report_info(String msg) {
        this.parser.report_info(msg);
        //System.err.println("INFO: " + msg);
    }
    void report_debug(String msg) {
        this.parser.report_debug(msg);
    }

    String printObj(Obj object) {
        return this.parser.printObj(object);
    }

    String printExpr(ExpressionToken expr) {
        return this.parser.printExpr(expr);
    }

:}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_06_terminals.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// RESERVED WORDS
terminal PROGRAM, ERROR;
terminal NEW, RETURN, VOID;
terminal FOR, BREAK, CONTINUE;
terminal CLASS, CONST, EXTENDS, STATIC;
terminal IF, ELSE;
terminal PRINT, READ;

// IDENTIFICATOR AND LITERALS
terminal String ID;
terminal Integer CONST_NUMBER;
terminal char CONST_CHAR;
terminal Boolean CONST_BOOL;

// OPERATORS
terminal ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, MODULO;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR;
terminal ASSIGN, ASSIGN_ADDITION, ASSIGN_SUBTRACTION, ASSIGN_MULTIPLICATION, ASSIGN_DIVISION, ASSIGN_MODULO;
terminal INCREMENT, DECREMENT;
terminal SEMICOLON, COMMA, DOT;
terminal PARENTHESES_LEFT, PARENTHESES_RIGHT, BRACKETS_LEFT, BRACKETS_RIGHT, BRACES_LEFT, BRACES_RIGHT;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_07_non_terminals.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

non terminal Program, ProgramName;
non terminal DeclarationList, Declaration;
non terminal VarDeclarationLine, VarDeclarationList, VarIDList;
non terminal ConstDeclarationLine, ConstIDList, ConstID, Const;
non terminal ClassDeclaration, ClassExtends, ClassName, ClassType;
non terminal MethodDeclarationSection, OptionalMethodDeclarationSection;
non terminal MethodDeclarationList, MethodDeclaration, MethodName;
non terminal OptionalStatic;
non terminal StatementBlock, StatementList, Statement, OptionalElse;
non terminal StatementDesignator, StatementIf, StatementFor, StatementBreak;
non terminal StatementContinue, StatementReturn, StatementRead, StatementPrint;
non terminal DesignatorStatement, OptionalDesignatorStatement;
non terminal ActualParameterSection, ActualParameterList, ActualParameter;
non terminal MemberList, Member;
non terminal OptionalDimension, Dimension;
non terminal OptionalMethodCall, MethodCall;
non terminal OptionalUnaryMinus;

non terminal String Designator;
non terminal String VarIDSingle, VarID;
non terminal ExpressionToken Expression;
non terminal ExpressionToken Term, AdditionTermList, Factor, MultiplicationFactorList;
non terminal String Type, MethodType;

non terminal Integer AdditionOperator, AdditionOperatorLeft, AdditionOperatorRight;
non terminal Integer MultiplicationOperator, MultiplicationOperatorLeft, MultiplicationOperatorRight;

non terminal Integer FormalParameterSection, FormalParameterList, FormalParameter;

non terminal ExpressionToken Condition, OptionalCondition, ConditionTermList, ConditionTerm, ConditionFactorList, ConditionFactor;
non terminal Integer RelationalOperator, AssignOperator;

precedence left ELSE;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_08_program.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Program ::= PROGRAM ProgramName DeclarationList MethodDeclarationSection
                {:
                    ctx.foundSymbol(SemanticSymbol.PROGRAM_EXIT,
                        new SemanticParameters());
                :};

ProgramName ::= ID:progName
                {:
                    ctx.foundSymbol(SemanticSymbol.PROGRAM,
                        new SemanticParameters()
                        .setName(progName.toString()));
                :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_09_declarations.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DeclarationList ::= DeclarationList Declaration
                    | /* epsilon */;

    Declaration ::= VarDeclarationLine
                    | ConstDeclarationLine
                    | ClassDeclaration;

           Type ::= ID:id
                    {:
                        // String id;
                        ctx.foundSymbol(SemanticSymbol.TYPE,
                            new SemanticParameters()
                            .setName(id));
                    :};

 OptionalStatic ::= STATIC
                    {:
                        ctx.foundSymbol(SemanticSymbol.STATIC,
                            new SemanticParameters());
                    :}
                    | /* epsilon */;

     MethodType ::= Type
                    | VOID
                    {:
                        ctx.foundSymbol(SemanticSymbol.TYPE,
                            new SemanticParameters()
                            .setName("void"));
                    :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_10_constants.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   ConstDeclarationLine ::= CONST Type ConstIDList SEMICOLON;

            ConstIDList ::= ConstIDList COMMA ConstID
                            | ConstID;

                ConstID ::= ID:id
                            {:
                                // String id;
                                ctx.foundSymbol(SemanticSymbol.CONST,
                                    new SemanticParameters()
                                    .setName(id));
                            :}
                            ASSIGN Const;

                  Const ::= CONST_NUMBER:val
                            {:
                                // Integer val;
                                ctx.foundSymbol(SemanticSymbol.CONST_VAL,
                                    new SemanticParameters()
                                    .setValue(val)
                                    .setType("int"));
                            :}
                            | CONST_CHAR:val
                            {:
                                // char val;
                                ctx.foundSymbol(SemanticSymbol.CONST_VAL,
                                    new SemanticParameters()
                                    .setValue((int)val)
                                    .setType("char"));
                            :}
                            | CONST_BOOL:val
                            {:
                                // boolean val;
                                ctx.foundSymbol(SemanticSymbol.CONST_VAL,
                                    new SemanticParameters()
                                    .setValue(val?1:0)
                                    .setType("bool"));
                            :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_11_variables.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 VarDeclarationList ::= VarDeclarationList VarDeclarationLine
                        | /* epsilon */;

 VarDeclarationLine ::= Type VarIDList SEMICOLON;

          VarIDList ::= VarIDList COMMA VarIDSingle
                        | VarIDSingle;

        VarIDSingle ::= VarID:varName
                        {:
                            // String varName;
                            ctx.foundSymbol(SemanticSymbol.VAR,
                                new SemanticParameters()
                                .setName(varName));

                        :}
                        | VarID:varName BRACKETS_LEFT BRACKETS_RIGHT
                        {:
                            // String varName;
                            ctx.foundSymbol(SemanticSymbol.ARRAY,
                                new SemanticParameters()
                                .setName(varName));
                        :};

              VarID ::= ID:id
                        {:
                            // String id;
                            RESULT = id;
                        :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_12_class.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   ClassDeclaration ::= CLASS ClassName ClassExtends
                        BRACES_LEFT VarDeclarationList
                        OptionalMethodDeclarationSection BRACES_RIGHT
                        {:
                            ctx.foundSymbol(SemanticSymbol.CLASS_EXIT,
                                new SemanticParameters());
                        :};

          ClassName ::= ID:id
                        {:
                            // String id;
                            ctx.foundSymbol(SemanticSymbol.CLASS,
                                new SemanticParameters()
                                .setName(id));
                        :};

       ClassExtends ::= EXTENDS ClassType
                        | /* epsilon */;

          ClassType ::= Type:typeName
                        {:
                            // String typeName;
                            ctx.foundSymbol(SemanticSymbol.TYPE_CLASS,
                                new SemanticParameters()
                                .setName(typeName));

                        :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_13_method.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

           MethodDeclarationSection ::= BRACES_LEFT MethodDeclarationList BRACES_RIGHT;

   OptionalMethodDeclarationSection ::= MethodDeclarationSection
                                        | /* epsilon */;

              MethodDeclarationList ::= MethodDeclarationList MethodDeclaration
                                        | /* epsilon */;

                  MethodDeclaration ::= OptionalStatic MethodType MethodName
                                        PARENTHESES_LEFT FormalParameterSection:numFormal PARENTHESES_RIGHT
                                        VarDeclarationList
                                        BRACES_LEFT
                                        {:
                                            // Integer numFormal;
                                            ctx.foundSymbol(SemanticSymbol.METHOD_START,
                                                new SemanticParameters()
                                                .setValue(numFormal));
                                        :}
                                        StatementList BRACES_RIGHT
                                        {:
                                            ctx.foundSymbol(SemanticSymbol.METHOD_EXIT,
                                                new SemanticParameters());
                                        :};

                         MethodName ::= ID:id
                                        {:
                                            // String id;
                                            ctx.foundSymbol(SemanticSymbol.METHOD,
                                                new SemanticParameters()
                                                .setName(id));
                                        :};

             FormalParameterSection ::= FormalParameterList:num
                                        {:
                                            // Integer num;
                                            RESULT = num;
                                        :}
                                        | /* epsilon */
                                        {:
                                            RESULT = 0;
                                        :};

                FormalParameterList ::= FormalParameterList:num1 COMMA FormalParameter
                                        {:
                                            // Integer num1;
                                            RESULT = num1 + 1;
                                        :}
                                        | FormalParameter
                                        {:
                                            RESULT = 1;
                                        :};

                    FormalParameter ::= Type:type ID:id
                                        {:
                                            // String type;
                                            // String id;
                                            ctx.foundSymbol(SemanticSymbol.FORMAL_PARAMETER,
                                                new SemanticParameters()
                                                .setType(type)
                                                .setName(id));
                                        :}
                                        | Type:type ID:id BRACKETS_LEFT BRACKETS_RIGHT
                                        {:
                                            // String type;
                                            // String id;
                                            ctx.foundSymbol(SemanticSymbol.FORMAL_PARAMETER_ARRAY,
                                                new SemanticParameters()
                                                .setType(type)
                                                .setName(id));
                                        :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_14_statements.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

     StatementBlock ::= BRACES_LEFT
                        {:
                            ctx.foundSymbol(SemanticSymbol.STATEMENT_BLOCK, null);
                        :}
                        StatementList BRACES_RIGHT
                        {:
                            ctx.foundSymbol(SemanticSymbol.STATEMENT_BLOCK_EXIT, null);
                        :};

      StatementList ::= StatementList Statement
                        | /* epsilon */;

          Statement ::= StatementDesignator
                        | StatementIf
                        | StatementFor
                        | StatementBreak
                        | StatementContinue
                        | StatementReturn
                        | StatementRead
                        | StatementPrint
                        | StatementBlock;

StatementDesignator ::= DesignatorStatement
                        {:
                        :}
                        SEMICOLON
                        {:
                        :};

        StatementIf ::= IF PARENTHESES_LEFT Condition PARENTHESES_RIGHT
                        {:
                            ctx.foundSymbol(SemanticSymbol.IFSTART,
                                new SemanticParameters());
                        :}
                        Statement OptionalElse;

       OptionalElse ::= ELSE
                        {:
                            ctx.foundSymbol(SemanticSymbol.ELSESTART,
                                new SemanticParameters());
                        :}
                        Statement
                        {:
                            ctx.foundSymbol(SemanticSymbol.ELSEEND,
                                new SemanticParameters());
                        :}
                        | /* epsilon */
                        {:
                            ctx.foundSymbol(SemanticSymbol.IFEND,
                                new SemanticParameters());
                        :};

       StatementFor ::= FOR PARENTHESES_LEFT
                        OptionalDesignatorStatement SEMICOLON
                        OptionalCondition SEMICOLON
                        OptionalDesignatorStatement SEMICOLON
                        PARENTHESES_RIGHT Statement;

     StatementBreak ::= BREAK SEMICOLON;

  StatementContinue ::= CONTINUE SEMICOLON;

    StatementReturn ::= RETURN SEMICOLON
                        {:
                            ctx.foundSymbol(SemanticSymbol.RETURN,
                                new SemanticParameters()
                                .setExpression(new ExpressionToken(
                                    Tab.noType,
                                    false)));
                        :}
                        | RETURN Expression:expression SEMICOLON
                        {:
                            // ExpressionToken expression;
                            ctx.foundSymbol(SemanticSymbol.RETURN,
                                new SemanticParameters()
                                .setExpression(expression));
                        :};

      StatementRead ::= READ PARENTHESES_LEFT Designator PARENTHESES_RIGHT SEMICOLON;

     StatementPrint ::= PRINT PARENTHESES_LEFT Expression:expr PARENTHESES_RIGHT SEMICOLON
                        {:
                            // ExpressionToken expr;
                            ctx.foundSymbol(SemanticSymbol.PRINT,
                                new SemanticParameters()
                                .setExpression(expr));
                        :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_15_designator.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

OptionalDesignatorStatement ::= DesignatorStatement
                                | /* epsilon */;

        DesignatorStatement ::= Designator:design AssignOperator Expression:expr
                                {:
                                    // ExpressionToken expr;
                                    // String design;
                                    ctx.foundSymbol(SemanticSymbol.DESIGNATOR_ASSIGN,
                                        new SemanticParameters()
                                        .setName(design)
                                        .setExpression(expr));

                                :}
                                | Designator:function MethodCall
                                {:
                                    // String function;
                                    ctx.foundSymbol(SemanticSymbol.METHOD_CALL,
                                        new SemanticParameters()
                                        .setName(function));
                                :}
                                | Designator INCREMENT
                                | Designator DECREMENT;

     ActualParameterSection ::= ActualParameterList
                                | /* epsilon */;

        ActualParameterList ::= ActualParameterList COMMA ActualParameter
                                | ActualParameter;

            ActualParameter ::= Expression:expression;

                 Designator ::= ID:id MemberList
                                {:
                                    // String id;
                                    ctx.foundSymbol(SemanticSymbol.DESIGNATOR,
                                        new SemanticParameters()
                                        .setName(id));

                                    RESULT = id;
                                :};

                 MemberList ::= MemberList Member
                                | /* epsilon */;

                     Member ::= DOT ID
                                | Dimension;

          OptionalDimension ::= Dimension
                                | /* epsilon */;

         OptionalMethodCall ::= MethodCall
                                | /* epsilon */;

                 MethodCall ::= PARENTHESES_LEFT ActualParameterSection PARENTHESES_RIGHT;

                  Dimension ::= BRACKETS_LEFT Expression BRACKETS_RIGHT;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_16_condition.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  OptionalCondition ::= Condition
                        | /* epsilon */;

          Condition ::= ConditionTermList:expression
                        {:
                            // ExpressionToken expression;
                            ctx.foundSymbol(SemanticSymbol.SINGLE_EXPRESSION,
                                new SemanticParameters()
                                .setExpression(expression)
                                .setType("bool"));
                            RESULT = expression;
                        :};

  ConditionTermList ::= ConditionTermList:expression1 OR ConditionTerm:expression2
                        {:
                            // ExpressionToken expression1;
                            // ExpressionToken expression2;
                            ctx.foundSymbol(SemanticSymbol.EXPRESSION,
                                new SemanticParameters()
                                .setExpression(expression1)
                                .setExpression2(expression2)
                                .setType("bool")
                                .setValue(Code.add));

                            RESULT = expression1;
                        :}
                        | ConditionTerm:expression
                        {:
                            // ExpressionToken expression;
                            RESULT = expression;
                        :}
                        ;

      ConditionTerm ::= ConditionFactorList:expression
                        {:
                            // ExpressionToken expression;
                            RESULT = expression;
                        :}
                        ;

ConditionFactorList ::= ConditionFactorList:expression1 AND ConditionFactor:expression2
                        {:
                            // ExpressionToken expression1;
                            // ExpressionToken expression2;
                            ctx.foundSymbol(SemanticSymbol.EXPRESSION,
                                new SemanticParameters()
                                .setExpression(expression1)
                                .setExpression2(expression2)
                                .setType("bool")
                                .setValue(Code.mul));

                            RESULT = expression1;
                        :}
                        | ConditionFactor:expression
                        {:
                            // ExpressionToken expression;
                            RESULT = expression;
                        :}
                        ;

    ConditionFactor ::= Expression:expression
                        {:
                            // ExpressionToken expression;
                            RESULT = expression;
                        :}
                        | Expression:expression1 RelationalOperator:operator Expression:expression2
                        {:
                            // ExpressionToken expression1;
                            // ExpressionToken expression2;

                            ctx.foundSymbol(SemanticSymbol.RELOP,
                                new SemanticParameters()
                                .setExpression(expression1)
                                .setExpression2(expression2)
                                .setValue(operator));

                            RESULT = new ExpressionToken(new Struct(Struct.Bool), false);
                        :};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_17_expression.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                 Expression ::= AdditionTermList:expression
                                {:
                                    // ExpressionToken expression;

                                    RESULT = expression;
                                :}
                                | SUBTRACTION AdditionTermList:expression
                                {:
                                    // ExpressionToken expression;

                                    ctx.foundSymbol(SemanticSymbol.SINGLE_EXPRESSION,
                                        new SemanticParameters()
                                        .setExpression(expression)
                                        .setType("int"));

                                    RESULT = expression;
                                :};


           AdditionTermList ::= AdditionTermList:expression1 AdditionOperator:operator Term:expression2
                                {:
                                    // ExpressionToken expression1;
                                    // ExpressionToken expression2;
                                    // Integer operator;

                                    ctx.foundSymbol(SemanticSymbol.EXPRESSION,
                                        new SemanticParameters()
                                        .setExpression(expression1)
                                        .setExpression2(expression2)
                                        .setType("int")
                                        .setValue(operator));

                                    RESULT = new ExpressionToken(expression1.objType, false);
                                :}
                                | Term:expression
                                {:
                                    // ExpressionToken expression;

                                    RESULT = expression;
                                :};

                       Term ::= MultiplicationFactorList:expression
                                {:
                                    // ExpressionToken expression;

                                    RESULT = expression;
                                :};

   MultiplicationFactorList ::= MultiplicationFactorList:expression1 MultiplicationOperator:operator Factor:expression2
                                {:
                                    // ExpressionToken expression1;
                                    // ExpressionToken expression2;
                                    // Integer operator;

                                    ctx.foundSymbol(SemanticSymbol.EXPRESSION,
                                        new SemanticParameters()
                                        .setExpression(expression1)
                                        .setExpression2(expression2)
                                        .setType("int")
                                        .setValue(operator));

                                    RESULT = new ExpressionToken(expression1.objType, false);
                                :}
                                | Factor:expression
                                {:
                                    // ExpressionToken expression;

                                    RESULT = expression;
                                :};

                     Factor ::= Designator:varName
                                {:
                                    // String varName;

                                    ctx.foundSymbol(SemanticSymbol.DESIGNATOR_FACTOR,
                                        new SemanticParameters()
                                        .setName(varName));

                                    RESULT = new ExpressionToken(Tab.find(varName).getType(), false);
                                :}
                                | Designator:function MethodCall
                                {:
                                    // String function;
                                    ctx.foundSymbol(SemanticSymbol.DESIGNATOR_FACTOR,
                                        new SemanticParameters()
                                        .setName(function));

                                    RESULT = new ExpressionToken(Tab.find(function).getType(), false);
                                :}
                                | CONST_NUMBER:val
                                {:
                                    // Integer val;

                                    ctx.foundSymbol(SemanticSymbol.CONST_FACTOR,
                                        new SemanticParameters()
                                        .setValue(val)
                                        .setType("int"));

                                    RESULT = new ExpressionToken(Tab.intType, false);
                                :}
                                | CONST_CHAR:val
                                {:
                                    // char val;

                                    ctx.foundSymbol(SemanticSymbol.CONST_FACTOR,
                                        new SemanticParameters()
                                        .setValue((int)val)
                                        .setType("char"));

                                    RESULT = new ExpressionToken(Tab.charType, false);
                                :}
                                | CONST_BOOL:val
                                {:
                                    // boolean val;

                                    ctx.foundSymbol(SemanticSymbol.CONST_FACTOR,
                                        new SemanticParameters()
                                        .setValue(val?1:0)
                                        .setType("bool"));

                                    RESULT = new ExpressionToken(new Struct(Struct.Bool), false);
                                :}
                                | NEW Type:type OptionalDimension
                                {:
                                    // String type;

                                    RESULT = new ExpressionToken(Tab.find(type).getType(), false);
                                :}
                                | PARENTHESES_LEFT Expression:expr PARENTHESES_RIGHT
                                {:
                                    // ExpressionToken expr;

                                    RESULT = expr;
                                :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_18_operators.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

           AdditionOperator ::= AdditionOperatorLeft:operator
                                {:
                                    // Integer operator;

                                    RESULT = operator;
                                :}
                                | AdditionOperatorRight:operator
                                {:
                                    // Integer operator;

                                    RESULT = operator;
                                :}
                                ;

       AdditionOperatorLeft ::= ADDITION
                                {:
                                    RESULT = Code.add;
                                :}
                                | SUBTRACTION
                                {:
                                    RESULT = Code.sub;
                                :}
                                ;

      AdditionOperatorRight ::= ASSIGN_ADDITION
                                | ASSIGN_SUBTRACTION;

     MultiplicationOperator ::= MultiplicationOperatorLeft:operator
                                {:
                                    // Integer operator;

                                    RESULT = operator;
                                :}
                                | MultiplicationOperatorRight:operator
                                {:
                                    // Integer operator;

                                    RESULT = operator;
                                :};

 MultiplicationOperatorLeft ::= MULTIPLICATION
                                {:
                                    RESULT = Code.mul;
                                :}
                                | DIVISION
                                {:
                                    RESULT = Code.div;
                                :}
                                | MODULO
                                {:
                                    RESULT = Code.rem;
                                :}
                                ;

MultiplicationOperatorRight ::= ASSIGN_MULTIPLICATION
                                | ASSIGN_DIVISION
                                | ASSIGN_MODULO;

         RelationalOperator ::= EQUAL
                                {:
                                    RESULT = Code.eq;
                                :}
                                | NOT_EQUAL
                                {:
                                    RESULT = Code.ne;
                                :}
                                | GREATER
                                {:
                                    RESULT = Code.gt;
                                :}
                                | GREATER_EQUAL
                                {:
                                    RESULT = Code.ge;
                                :}
                                | LESS
                                {:
                                    RESULT = Code.lt;
                                :}
                                | LESS_EQUAL
                                {:
                                    RESULT = Code.le;
                                :};

             AssignOperator ::= ASSIGN
                                | AdditionOperatorRight
                                | MultiplicationOperatorRight;