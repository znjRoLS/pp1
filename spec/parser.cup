

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_01_import.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

package rosko.bojan;

import java_cup.runtime.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;

import rosko.bojan.SymbolCounter;
import rosko.bojan.SemanticContext.SemanticSymbol.*;
import rosko.bojan.SemanticContext.SemanticSymbol;

import rosko.bojan.ExpressionToken;

import java.util.HashMap;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_02_parser_code.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

parser code {:
    Logger logger = LogManager.getLogger(Parser.class);
    Scanner scanner;
    Symbol currSym;
    Boolean errorDetected;

    public SemanticContext context = new SemanticContext(this);

    void report_error(String msg) {
        errorDetected = true;
        logger.error(msg);
        //System.err.println("ERROR: " + msg);
    }
    void report_info(String msg) {
        logger.info(msg);
        //System.err.println("INFO: " + msg);
    }
    void report_debug(String msg) {
        logger.debug(msg);
        //System.err.println("INFO: " + msg);
    }
    void dump() {
        context.dumpTable();
    }

    public static String printExpr(ExpressionToken expr) {
        return "type: " + printObjKind(expr.objType.getKind()) + ", val: " + (expr.isVar?"lvalue":"rvalue");
    }

    public static String printObj(Obj object){
        return "name: " + object.getName() +
                ", type: " + printObjKind(object.getType().getKind()) +
                ", kind: " + printObjType(object.getKind());
    }

    public static String printObjType(int type) {
            // public static final int Con = 0, Var = 1, Type = 2, Meth = 3, Fld = 4, Elem=5, Prog = 6;
            final HashMap<Integer, String> typeMap = new HashMap<Integer, String>() {
                {
                    put(0, "Con");
                    put(1, "Var");
                    put(2, "Type");
                    put(3, "Meth");
                    put(4, "Fld");
                    put(5, "Elem");
                    put(6, "Prog");
                }
            };

            return typeMap.get(type);
        }

        public static String printObjKind(int type) {
            // kodiranje tipova
            // public static final int None = 0;
            // public static final int Int = 1;
            // public static final int Char = 2;
            // public static final int Array = 3;
            // public static final int Class = 4;
            // public static final int Bool = 5;
            final HashMap<Integer, String> typeMap = new HashMap<Integer, String>() {
                {
                    put(0, "None");
                    put(1, "Int");
                    put(2, "Char");
                    put(3, "Array");
                    put(4, "Class");
                    put(5, "Bool");
                }
            };

            return typeMap.get(type);

        }

:}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_03_scan_code.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

scan with {:
    currSym = scanner.next_token();
    if (currSym != null && currSym.value != null) {
        report_info("Parsed symbol: " + currSym.value + " - " + currSym);
    }
    return currSym;
:}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_04_init_code.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

init with {:
    errorDetected = false;
    scanner = this.getScanner();
    Tab.init();

    Obj voidObj = Tab.insert(Obj.Type, "void", new Struct(Struct.None));
    Obj boolObj = Tab.insert(Obj.Type, "bool", new Struct(Struct.Bool));

    voidObj.setAdr(-1);
    boolObj.setAdr(-1);
    voidObj.setLevel(-1);
    boolObj.setLevel(-1);

    action_obj.ctx = context;
:}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_05_action_code.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

action code {:

    enum ValueType {
        LVALUE,
        RVALUE
    }

    final Pair<Integer, ValueType> EMPTY_VALUE = new Pair<Integer, ValueType>(-1, ValueType.RVALUE);

    Obj currentMethod = null;
    Struct currentVarDeclType;

    SemanticContext ctx;


    void report_error(String msg) {
        this.parser.report_error(msg);
        //System.err.println("ERROR: " + msg);
    }
    void report_info(String msg) {
        this.parser.report_info(msg);
        //System.err.println("INFO: " + msg);
    }
    void report_debug(String msg) {
        this.parser.report_debug(msg);
    }

    String printObj(Obj object) {
        return this.parser.printObj(object);
    }

    String printExpr(ExpressionToken expr) {
        return this.parser.printExpr(expr);
    }

:}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_06_terminals.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// RESERVED WORDS
terminal PROGRAM, ERROR;
terminal NEW, RETURN, VOID;
terminal FOR, BREAK, CONTINUE;
terminal CLASS, CONST, EXTENDS, STATIC;
terminal IF, ELSE;
terminal PRINT, READ;

// IDENTIFICATOR AND LITERALS
terminal ID;
terminal Integer CONST_NUMBER;
terminal char CONST_CHAR;
terminal Boolean CONST_BOOL;

// OPERATORS
terminal ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, MODULO;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR;
terminal ASSIGN, ASSIGN_ADDITION, ASSIGN_SUBTRACTION, ASSIGN_MULTIPLICATION, ASSIGN_DIVISION, ASSIGN_MODULO;
terminal INCREMENT, DECREMENT;
terminal SEMICOLON, COMMA, DOT;
terminal PARENTHESES_LEFT, PARENTHESES_RIGHT, BRACKETS_LEFT, BRACKETS_RIGHT, BRACES_LEFT, BRACES_RIGHT;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_07_non_terminals.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

non terminal Program, ProgramName;
non terminal DeclarationList, Declaration;
non terminal VarDeclarationLine, VarDeclarationList, VarID, VarIDList, VarIDSingle;
non terminal ConstDeclarationLine, ConstIDList, ConstID, Const;
non terminal ClassDeclaration, ClassExtends, ClassName, ClassType;
non terminal MethodDeclarationSection, OptionalMethodDeclarationSection;
non terminal MethodDeclarationList, MethodDeclaration, MethodName;
non terminal OptionalStatic;
non terminal StatementBlock, StatementList, Statement, OptionalElse;
non terminal StatementDesignator, StatementIf, StatementFor, StatementBreak;
non terminal StatementContinue, StatementReturn, StatementRead, StatementPrint;
non terminal DesignatorStatement, OptionalDesignatorStatement;
non terminal ActualParameterSection, ActualParameterList, ActualParameter;
non terminal MemberList, Member;
non terminal OptionalDimension, Dimension;
non terminal OptionalMethodCall, MethodCall;
non terminal OptionalUnaryMinus;

non terminal Obj Designator;
non terminal ExpressionToken Expression;
non terminal ExpressionToken Term, AdditionTermList, Factor, MultiplicationFactorList;
non terminal Obj Type, MethodType;

non terminal Integer AdditionOperator, AdditionOperatorLeft, AdditionOperatorRight;
non terminal Integer MultiplicationOperator, MultiplicationOperatorLeft, MultiplicationOperatorRight;

non terminal Integer FormalParameterSection, FormalParameterList, FormalParameter;

non terminal ExpressionToken Condition, OptionalCondition, ConditionTermList, ConditionTerm, ConditionFactorList, ConditionFactor;
non terminal Integer RelationalOperator, AssignOperator;

precedence left ELSE;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_08_program.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    Program ::= PROGRAM
                {:
                    //report_info("Program 1");
                :}
                ProgramName
                {:
                    //report_info("Program 2");
                :}
                DeclarationList
                {:
                    //report_info("Program 3");
                :}
                MethodDeclarationSection
                {:
                    //report_info("Program 4");
                    ctx.foundSymbol(SemanticSymbol.PROGRAM_EXIT, null);
                :};

ProgramName ::= ID:progName
                {:
                    ctx.foundSymbol(SemanticSymbol.PROGRAM, progName.toString());
                    //report_info("Parsed program name " + progName);
                :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_09_declarations.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DeclarationList ::= DeclarationList Declaration
                    {:
                        report_info("Declaration list Declaration");
                    :}
                    | /* epsilon */
                    {:
                        report_info("Declaration list epsilon");
                    :};

    Declaration ::= VarDeclarationLine
                    | ConstDeclarationLine
                    | ClassDeclaration;

           Type ::= ID:id
                    {:
                        String name = id.toString();
                        Obj node = Tab.find(name);
                        if (node == Tab.noObj) {
                            report_error("Type not declared: " + name);
                        } else if (node.getKind() != Obj.Type) {
                            report_error("Token doesn't represent type: " + name);
                        }
                        ctx.foundSymbol(SemanticSymbol.TYPE, id.toString());
                        report_info("Matched type " + id);
                        RESULT = node;
                    :};

 OptionalStatic ::= STATIC
                    {:
                        ctx.foundSymbol(SemanticSymbol.STATIC, null);
                    :}
                    | /* epsilon */;

     MethodType ::= Type:id
                    | VOID
                    {:
                        ctx.foundSymbol(SemanticSymbol.TYPE, "void");
                    :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_10_constants.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   ConstDeclarationLine ::= CONST Type ConstIDList SEMICOLON;

            ConstIDList ::= ConstIDList COMMA ConstID
                            | ConstID;

                ConstID ::= ID:constObj
                            {:
                                ctx.foundSymbol(SemanticSymbol.CONST, constObj.toString());
                                //report_info("ConstDeclaration " + constObj);
                            :}
                            ASSIGN Const;

                  Const ::= CONST_NUMBER:val
                            {:
                                // Integer val;
                                ctx.setConstValue(val);
                            :}
                            | CONST_CHAR:val
                            {:
                                // char val;
                                ctx.setConstValue(val);
                            :}
                            | CONST_BOOL:val
                            {:
                                // bool val;
                                ctx.setConstValue(val);
                            :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_11_variables.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 VarDeclarationList ::= VarDeclarationList VarDeclarationLine
                        | /* epsilon */;

 VarDeclarationLine ::= Type VarIDList SEMICOLON;

          VarIDList ::= VarIDList COMMA VarIDSingle
                        | VarIDSingle;

        VarIDSingle ::= VarID:varObj
                        {:
                            ctx.foundSymbol(SemanticSymbol.VAR, varObj.toString());
                            report_info("VarDeclaration 1 " + varObj);
                        :}
                        | VarID:varObj
                        {:
                            report_info("VarDeclaration 3 " + varObj);
                        :}
                        BRACKETS_LEFT
                        {:
                            report_info("VarDeclaration 4 " + varObj);
                        :}
                        BRACKETS_RIGHT
                        {:
                            ctx.foundSymbol(SemanticSymbol.ARRAY, varObj.toString());
                            report_info("VarDeclaration 2 " + varObj);
                        :};

              VarID ::= ID:id
                        {:
                            RESULT = id;
                        :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_12_class.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   ClassDeclaration ::= CLASS ClassName ClassExtends
                        BRACES_LEFT VarDeclarationList
                        OptionalMethodDeclarationSection BRACES_RIGHT
                        {:
                            ctx.foundSymbol(SemanticSymbol.CLASS_EXIT, null);
                        :};

          ClassName ::= ID:id
                        {:
                            ctx.foundSymbol(SemanticSymbol.CLASS, id.toString());
                            report_info("Entered class: " + id);
                        :};

       ClassExtends ::= EXTENDS ClassType
                        {:
                            report_info ("Parsed nonempty class extends");
                        :}
                        | /* epsilon */
                        {:
                            report_info ("Parsed empty class extends");
                        :};

          ClassType ::= Type:type
                        {:
                            //ctx.foundSymbol(SemanticSymbol.TYPE_CLASS, type.toString());
                            // Struct type;
                            if (type.getType().getKind() != Struct.Class) {
                                report_error("Token not of class type: " + type.getName() + " " + printObj(type));
                            }
                        :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_13_method.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

           MethodDeclarationSection ::= BRACES_LEFT MethodDeclarationList BRACES_RIGHT;

   OptionalMethodDeclarationSection ::= MethodDeclarationSection
                                        | /* epsilon */;

              MethodDeclarationList ::= MethodDeclarationList MethodDeclaration
                                        | /* epsilon */;

                  MethodDeclaration ::= OptionalStatic MethodType MethodName
                                        PARENTHESES_LEFT FormalParameterSection:num PARENTHESES_RIGHT
                                        VarDeclarationList
                                        BRACES_LEFT
                                        {:
                                            //ctx.foundSymbol(SemanticSymbol.METHOD_START, null);
                                            ctx.symbolMethodStart(num);
                                        :}
                                        StatementList BRACES_RIGHT
                                        {:
                                            ctx.foundSymbol(SemanticSymbol.METHOD_EXIT, null);
                                        :};

                         MethodName ::= ID:id
                                        {:
                                            ctx.foundSymbol(SemanticSymbol.METHOD, id.toString());
                                            report_info("Entered method: " + id);
                                        :};

             FormalParameterSection ::= FormalParameterList:num
                                        {:
                                            RESULT = num;
                                        :}
                                        | /* epsilon */
                                        {:
                                            RESULT = 0;
                                        :};

                FormalParameterList ::= FormalParameterList:num1 COMMA FormalParameter
                                        {:
                                            RESULT = num1 + 1;
                                        :}
                                        | FormalParameter
                                        {:
                                            RESULT = 1;
                                        :};

                    FormalParameter ::= Type:type ID:id
                                        {:
                                            //ctx.foundSymbol(SemanticSymbol.FORMAL_PARAMETER, id.toString());
                                            ctx.symbolFormalParameter(type.getType(), id.toString());
                                        :}
                                        | Type:type ID:id
                                        {:
                                            ctx.symbolFormalParameterArr(type.getType(), id.toString());
                                        :}
                                        BRACKETS_LEFT BRACKETS_RIGHT;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_14_statements.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

     StatementBlock ::= BRACES_LEFT
                        {:
                            ctx.foundSymbol(SemanticSymbol.STATEMENT_BLOCK, null);
                        :}
                        StatementList BRACES_RIGHT
                        {:
                            ctx.foundSymbol(SemanticSymbol.STATEMENT_BLOCK_EXIT, null);
                        :};

      StatementList ::= StatementList Statement
                        | /* epsilon */;

          Statement ::= StatementDesignator
                        | StatementIf
                        | StatementFor
                        | StatementBreak
                        | StatementContinue
                        | StatementReturn
                        | StatementRead
                        | StatementPrint
                        | StatementBlock;

StatementDesignator ::= DesignatorStatement
                        {:
                        :}
                        SEMICOLON
                        {:
                        :};

        StatementIf ::= IF PARENTHESES_LEFT Condition PARENTHESES_RIGHT
                        {:
                            ctx.symbolIf();
                        :}
                        Statement OptionalElse;

       OptionalElse ::= ELSE
                        {:
                            ctx.symbolIfElse();
                        :}
                        Statement
                        {:
                            ctx.symbolIfElseEnd();
                        :}
                        | /* epsilon */
                        {:
                            ctx.symbolIfEnd();
                        :};

       StatementFor ::= FOR PARENTHESES_LEFT
                        OptionalDesignatorStatement SEMICOLON
                        OptionalCondition SEMICOLON
                        OptionalDesignatorStatement SEMICOLON
                        PARENTHESES_RIGHT Statement;

     StatementBreak ::= BREAK SEMICOLON;

  StatementContinue ::= CONTINUE SEMICOLON;

    StatementReturn ::= RETURN SEMICOLON
                        {:
                            ctx.symbolReturn(null);
                        :}
                        | RETURN Expression:expression SEMICOLON
                        {:
                            ctx.symbolReturn(expression);
                            //ctx.foundSymbol(SemanticSymbol.RETURN, null);
                        :};

      StatementRead ::= READ PARENTHESES_LEFT Designator PARENTHESES_RIGHT SEMICOLON;

     StatementPrint ::= PRINT PARENTHESES_LEFT Expression:expr PARENTHESES_RIGHT SEMICOLON
                        {:
                            // ExpressionToken expr;
                            report_debug(printExpr(expr));
                            if (expr.objType.getKind() == Struct.Int) {
                            report_debug("found printint statement!");
                                Code.loadConst(5);
                                Code.put(Code.print);
                            } else if (expr.objType.getKind() == Struct.Char) {
                            report_debug("found printchar statement!");
                                Code.loadConst(1);
                                Code.put(Code.bprint);
                            }
                            report_debug("found print statement!");
                        :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_15_designator.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

OptionalDesignatorStatement ::= DesignatorStatement
                                | /* epsilon */;

        DesignatorStatement ::= Designator:design AssignOperator Expression:expr
                                {:
                                    // ExpressionToken expr;
                                    // Obj design;
                                    report_info("Found assign statement");
                                    if (expr.objType.getKind() != design.getType().getKind()) {
                                        //report_info("expr " + printExpr(expr) + "| design " + printObj(design));
                                        //report_info(expr.objType.getKind() + " " + design.getType().getKind());
                                        report_error("Not assignable!");
                                    } else {
                                        Code.store(design);
                                    }

                                :}
                                | Designator:function MethodCall
                                {:
                                    // Obj function;
                                    report_info("Function call: " + function.getName());
                                    if (function.getKind() != Obj.Meth) {
                                        report_error("Not a function!");
                                    }
                                    if (function.getType() == Tab.noType) {
                                        report_error("Function doesn't return value!");
                                    }
                                    int functionAdr = function.getAdr() - Code.pc;
                                    Code.put(Code.call);
                                    Code.put2(functionAdr);
                                    if (function.getType() != Tab.noType) {
                                        Code.put(Code.pop);
                                    }

                                :}
                                | Designator INCREMENT
                                | Designator DECREMENT;

     ActualParameterSection ::= ActualParameterList
                                | /* epsilon */;

        ActualParameterList ::= ActualParameterList COMMA ActualParameter
                                | ActualParameter;

            ActualParameter ::= Expression:expression;

                 Designator ::= ID:id
                                {:
                                    ctx.foundSymbol(SemanticSymbol.DESIGNATOR, id.toString());
                                    Obj found = Tab.find(id.toString());
                                    if (found == Tab.noObj) {
                                        report_error("Identifier name not declared: " + id.toString());
                                        RESULT = null;
                                    } else {
                                        //RESULT = new ExpressionToken(found.getType(), found.getType().getKind() == Obj.Var);
                                        //report_info("nestoasdasd " + printObj(found));
                                        RESULT = found;
                                    }
                                :}
                                MemberList;

                 MemberList ::= MemberList Member
                                | /* epsilon */;

                     Member ::= DOT ID
                                | Dimension;

          OptionalDimension ::= Dimension
                                | /* epsilon */;

         OptionalMethodCall ::= MethodCall
                                | /* epsilon */;

                 MethodCall ::= PARENTHESES_LEFT ActualParameterSection PARENTHESES_RIGHT
                                {:
                                    ctx.foundSymbol(SemanticSymbol.METHOD_CALL, null);
                                :};

                  Dimension ::= BRACKETS_LEFT Expression BRACKETS_RIGHT;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_16_condition.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  OptionalCondition ::= Condition
                        | /* epsilon */;

          Condition ::= ConditionTermList:expression
                        {:
                            // ExpressionToken expression;
                            RESULT = expression;
                        :};

  ConditionTermList ::= ConditionTermList:expression1 OR ConditionTerm:expression2
                        {:
                            // ExpressionToken expression1;
                            // ExpressionToken expression2;
                            if (expression1.objType.getKind() != Struct.Bool) {
                                report_error("Expression not boolean! " + printExpr(expression1));
                            }
                            if (expression2.objType.getKind() != Struct.Bool) {
                                report_error("Expression not boolean! " + printExpr(expression2));
                            }
                            Code.put(Code.add);
                            RESULT = expression1;
                        :}
                        | ConditionTerm:expression
                        {:
                            // ExpressionToken expression;
                            RESULT = expression;
                        :}
                        ;

      ConditionTerm ::= ConditionFactorList:expression
                        {:
                            // ExpressionToken expression;
                            if (expression.objType.getKind() != Struct.Bool) {
                                report_error("Condition not of type bool!");
                            }
                            RESULT = expression;
                        :}
                        ;

ConditionFactorList ::= ConditionFactorList:expression1 AND ConditionFactor:expression2
                        {:
                            // ExpressionToken expression1;
                            // ExpressionToken expression2;
                            if (expression1.objType.getKind() != Struct.Bool) {
                                report_error("Expression not boolean! " + printExpr(expression1));
                            }
                            if (expression2.objType.getKind() != Struct.Bool) {
                                report_error("Expression not boolean! " + printExpr(expression2));
                            }
                            Code.put(Code.mul);
                            RESULT = expression1;
                        :}
                        | ConditionFactor:expression
                        {:
                            // ExpressionToken expression;
                            if (expression.objType.getKind() != Struct.Bool) {
                                report_error("Condition not of type bool!");
                            }
                            RESULT = expression;
                        :}
                        ;

    ConditionFactor ::= Expression:expression
                        {:
                            // ExpressionToken expression;
                            if (expression.objType.getKind() != Struct.Bool) {
                                report_error("Condition not of type bool!");
                            }
                            RESULT = expression;
                        :}
                        | Expression:expression1 RelationalOperator:operator Expression:expression2
                        {:
                            // ExpressionToken expression1;
                            // ExpressionToken expression2;
                            if (!expression1.compatible(expression2)) {
                                report_error("Expressions not compatible! " + printExpr(expression1) + " - " + printExpr(expression2));
                            }
                            ctx.symbolRelop(operator);
                            RESULT = new ExpressionToken(new Struct(Struct.Bool), false);
                        :};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_17_expression.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                 Expression ::= AdditionTermList:expression
                                {:
                                    RESULT = expression;
                                :}
                                | SUBTRACTION AdditionTermList:expression
                                {:
                                    if (expression.objType.getKind() != Struct.Int) {
                                        report_error("Type not int: " + printExpr(expression) );
                                        RESULT = null;
                                    }
                                    RESULT = expression;
                                :};


           AdditionTermList ::= AdditionTermList:expression1 AdditionOperator:operator Term:expression2
                                {:
                                    if (expression1.objType.getKind() != expression2.objType.getKind()) {
                                        report_error("Types not the same: " + printExpr(expression1) + " - " + printExpr(expression2));
                                        RESULT = null;
                                    } else if (expression1.objType.getKind() != Struct.Int) {
                                        report_error("Types same, but not integer: " + printExpr(expression1));
                                        RESULT = null;
                                    } else {
                                        RESULT = new ExpressionToken(expression1.objType, false);
                                    }
                                    Code.put(operator);
                                :}
                                | Term:expression
                                {:
                                    RESULT = expression;
                                :};

                       Term ::= MultiplicationFactorList:expression
                                {:
                                    RESULT = expression;
                                :};

   MultiplicationFactorList ::= MultiplicationFactorList:expression1 MultiplicationOperator:operator Factor:expression2
                                {:
                                    if (expression1.objType.getKind() != expression2.objType.getKind()) {
                                        report_error("Types not the same: " + printExpr(expression1) + " - " + printExpr(expression2));
                                        RESULT = null;
                                    } else if (expression1.objType.getKind() != Struct.Int) {
                                        report_error("Types same, but not integer: " + printExpr(expression1));
                                        RESULT = null;
                                    } else {
                                        RESULT = new ExpressionToken(expression1.objType, false);
                                    }
                                    Code.put(operator);
                                :}
                                | Factor:expression
                                {:
                                    RESULT = expression;
                                :};

                     Factor ::= Designator:varObj
                                {:
                                    // Obj varObj;

                                    report_info("Found designator factor: " + varObj.getName());
                                    int objectType = varObj.getKind();
                                    if (objectType != Obj.Var && objectType != Obj.Con) {
                                        report_error("Object not a constant or variable or class or field or element: " + printObj(varObj));
                                        RESULT = null;
                                    } else {
                                        Struct objType = varObj.getType();
                                        RESULT = new ExpressionToken(objType, false);
                                    }
                                    Code.load(varObj);
                                :}
                                | Designator:function MethodCall
                                {:
                                    // Obj function;
                                    report_info("Function expression call: " + function.getName());
                                    int objectType = function.getKind();
                                    if (objectType != Obj.Meth) {
                                        report_error("Object not a method: " + printObj(function));
                                        RESULT = null;
                                    } else {
                                        int functionAdr = function.getAdr() - Code.pc;
                                        Code.put(Code.call);
                                        Code.put2(functionAdr);

                                        Struct methodReturnType = function.getType();
                                        RESULT = new ExpressionToken(methodReturnType, false);
                                    }
                                :}
                                | CONST_NUMBER:val
                                {:
                                    // Integer val;
                                    Obj c = Tab.insert(Obj.Con, null, Tab.intType);
                                    c.setAdr(val);
                                    Code.load(c);
                                    //report_info("nesto " + val);
                                    RESULT = new ExpressionToken(Tab.intType, false);
                                :}
                                | CONST_CHAR:val
                                {:
                                    // char val;
                                    Obj c = Tab.insert(Obj.Con, null, Tab.charType);
                                    c.setAdr(val);
                                    Code.load(c);
                                    RESULT = new ExpressionToken(Tab.charType, false);
                                :}
                                | CONST_BOOL:val
                                {:
                                    // boolean val;
                                    Struct boolType = new Struct(Struct.Bool);
                                    Obj c = Tab.insert(Obj.Con, null, boolType);
                                    c.setAdr(val?1:0);
                                    Code.load(c);
                                    RESULT = new ExpressionToken(boolType, false);
                                :}
                                | NEW Type:type OptionalDimension
                                {:
                                    RESULT = new ExpressionToken(type.getType(), false);
                                :}
                                | PARENTHESES_LEFT Expression:expr PARENTHESES_RIGHT
                                {:
                                    RESULT = expr;
                                :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// parser_18_operators.cup
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

           AdditionOperator ::= AdditionOperatorLeft:operator
                                {:
                                    RESULT = operator;
                                :}
                                | AdditionOperatorRight:operator
                                {:
                                    RESULT = operator;
                                :}
                                ;

       AdditionOperatorLeft ::= ADDITION
                                {:
                                    RESULT = Code.add;
                                :}
                                | SUBTRACTION
                                {:
                                    RESULT = Code.sub;
                                :}
                                ;

      AdditionOperatorRight ::= ASSIGN_ADDITION
                                | ASSIGN_SUBTRACTION;

     MultiplicationOperator ::= MultiplicationOperatorLeft:operator
                                {:
                                    RESULT = operator;
                                :}
                                | MultiplicationOperatorRight:operator
                                {:
                                    RESULT = operator;
                                :};

 MultiplicationOperatorLeft ::= MULTIPLICATION
                                {:
                                    RESULT = Code.mul;
                                :}
                                | DIVISION
                                {:
                                    RESULT = Code.div;
                                :}
                                | MODULO
                                {:
                                    RESULT = Code.rem;
                                :}
                                ;

MultiplicationOperatorRight ::= ASSIGN_MULTIPLICATION
                                | ASSIGN_DIVISION
                                | ASSIGN_MODULO;

         RelationalOperator ::= EQUAL
                                {:
                                    RESULT = Code.eq;
                                :}
                                | NOT_EQUAL
                                {:
                                    RESULT = Code.ne;
                                :}
                                | GREATER
                                {:
                                    RESULT = Code.gt;
                                :}
                                | GREATER_EQUAL
                                {:
                                    RESULT = Code.ge;
                                :}
                                | LESS
                                {:
                                    RESULT = Code.lt;
                                :}
                                | LESS_EQUAL
                                {:
                                    RESULT = Code.le;
                                :};

             AssignOperator ::= ASSIGN
                                | AdditionOperatorRight
                                | MultiplicationOperatorRight;