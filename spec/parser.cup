package rosko.bojan;

import java_cup.runtime.*;
import java.util.logging.Logger;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

//////////////////////////////////////////////

parser code {:
    Logger log = Logger.getLogger(Parser.class.toString());
    Scanner scanner;
    Symbol currSym;

    void report_error(String msg) {
        //this.parser.log.info("ERROR: " + msg);
        System.err.println("ERROR: " + msg);
    }
    void report_info(String msg) {
        //this.parser.log.info("INFO: " + msg);
        System.err.println("INFO: " + msg);
    }
:}

init with {:
    scanner = this.getScanner();
    Tab.init();

    Tab.insert(Obj.Con, "void", Tab.nullType);
:}

scan with {:
    currSym = scanner.next_token();
    if (currSym != null && currSym.value != null) {
        report_info("Parsed symbol: " + currSym.value + " - " + currSym);
    }
    return currSym;
:}

action code {:
    Obj currentMethod = null;
    Struct currentVarDeclType;

    void report_error(String msg) {
        //this.parser.log.info("ERROR: " + msg);
        System.err.println("ERROR: " + msg);
    }
    void report_info(String msg) {
        //this.parser.log.info("INFO: " + msg);
        System.err.println("INFO: " + msg);
    }
:}

////////////////////////////////////////////////

// TERMINALS
////////////////////////////////////////////////

// RESERVED WORDS
terminal PROGRAM, ERROR;
terminal NEW, RETURN, VOID;
terminal FOR, BREAK, CONTINUE;
terminal CLASS, CONST, EXTENDS, STATIC;
terminal IF, ELSE;
terminal PRINT, READ;

// IDENTIFICATOR AND LITERALS
terminal ID, CONST_NUMBER, CONST_CHAR, CONST_BOOL;

// OPERATORS
terminal ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, MODULO;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR;
terminal ASSIGN, ASSIGN_ADDITION, ASSIGN_SUBTRACTION, ASSIGN_MULTIPLICATION, ASSIGN_DIVISION, ASSIGN_MODULO;
terminal INCREMENT, DECREMENT;
terminal SEMICOLON, COMMA, DOT;
terminal PARENTHESES_LEFT, PARENTHESES_RIGHT, BRACKETS_LEFT, BRACKETS_RIGHT, BRACES_LEFT, BRACES_RIGHT;

////////////////////////////////////////////////

// NON TERMINALS
////////////////////////////////////////////////

non terminal Program, ProgramName;
non terminal DeclarationList, Declaration;
non terminal VarDeclarationLine, VarDeclarationList, VarID, VarIDList;
non terminal ConstDeclarationLine, ConstIDList, ConstID, Const;
non terminal ClassDeclaration, ClassExtends;
non terminal MethodDeclarationSection, OptionalMethodDeclarationSection, MethodDeclarationList, MethodDeclaration;
non terminal FormalParameterSection, FormalParameterList, FormalParameter;
non terminal Type, MethodType, OptionalStatic;
non terminal StatementBlock, StatementList, Statement;
non terminal StatementDesignator, StatementIf, StatementFor, StatementBreak;
non terminal StatementContinue, StatementReturn, StatementRead, StatementPrint;
non terminal DesignatorStatement, OptionalDesignatorStatement, Designator;
non terminal Condition, OptionalCondition;
non terminal Expression;

precedence left ELSE;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                                      PROGRAM
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                        Program ::= PROGRAM ProgramName:progObj DeclarationList
                                                    {:
                                                        report_info("Program just before left braces");
                                                    :}
                                                    MethodDeclarationSection
                                                    {:
                                                        report_info("Parsed whole program");
                                                    :};

                                    ProgramName ::= ID:progName
                                                    {:
                                                        report_info("Parsed program name " + progName);
                                                    :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                                 DECLARATIONS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                DeclarationList ::= DeclarationList Declaration
                                                    {:
                                                        report_info("Declaration list Declaration");
                                                    :}
                                                    | /* epsilon */
                                                    {:
                                                        report_info("Declaration list epsilon");
                                                    :};

                                    Declaration ::= VarDeclarationLine
                                                    | ConstDeclarationLine
                                                    | ClassDeclaration;

                                           Type ::= ID:id
                                                    {:
                                                        report_info("Matched type " + id);
                                                    :};

                                 OptionalStatic ::= STATIC
                                                    | /* epsilon */;

                                     MethodType ::= Type:id
                                                    | VOID;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                        CONSTANTS DECLARATION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                           ConstDeclarationLine ::= CONST Type ConstIDList SEMICOLON;

                                    ConstIDList ::= ConstIDList COMMA ConstID
                                                    | ConstID;

                                        ConstID ::= ID:constObj ASSIGN Const
                                                    {:
                                                        report_info("ConstDeclaration " + constObj);
                                                    :};

                                          Const ::= CONST_NUMBER
                                                    | CONST_CHAR
                                                    | CONST_BOOL;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                              VAR DECLARATION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                             VarDeclarationList ::= VarDeclarationList VarDeclarationLine
                                                    | /* epsilon */;

                             VarDeclarationLine ::= Type VarIDList SEMICOLON;

                                      VarIDList ::= VarIDList COMMA VarID
                                                    | VarID;

                                          VarID ::= ID
                                                    | ID:varObj BRACKETS_LEFT BRACKETS_RIGHT
                                                    {:
                                                        report_info("VarDeclaration " + varObj);
                                                    :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                            CLASS DECLARATION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                               ClassDeclaration ::= CLASS ID ClassExtends
                                                    BRACES_LEFT VarDeclarationList
                                                    OptionalMethodDeclarationSection BRACES_RIGHT
                                                    {:
                                                        report_info("Parsed class declaration!");
                                                    :};

                                   ClassExtends ::= EXTENDS Type
                                                    {:
                                                        report_info ("Parsed nonempty class extends");
                                                    :}
                                                    | /* epsilon */
                                                    {:
                                                        report_info ("Parsed empty class extends");
                                                    :};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                           METHOD DECLARATION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                       MethodDeclarationSection ::= BRACES_LEFT MethodDeclarationList BRACES_RIGHT;

               OptionalMethodDeclarationSection ::= MethodDeclarationSection
                                                    | /* epsilon */;

                          MethodDeclarationList ::= MethodDeclarationList MethodDeclaration
                                                    | /* epsilon */;

                              MethodDeclaration ::= OptionalStatic MethodType ID:id
                                                    PARENTHESES_LEFT FormalParameterSection PARENTHESES_RIGHT
                                                    VarDeclarationList
                                                    StatementBlock
                                                    {:
                                                        report_info("Matched method " + id);
                                                    :};

                        FormalParameterSection ::= FormalParameterList
                                                    | /* epsilon */;

                           FormalParameterList ::= FormalParameterList COMMA FormalParameter
                                                    | FormalParameter;

                                FormalParameter ::= Type ID
                                                    | Type ID BRACKETS_LEFT BRACKETS_RIGHT;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                                   STATEMENTS
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                                 StatementBlock ::= BRACES_LEFT StatementList BRACES_RIGHT;

                                  StatementList ::= StatementList Statement
                                                    | /* epsilon */;

                                      Statement ::= StatementDesignator
                                                    | StatementIf
                                                    | StatementFor
                                                    | StatementBreak
                                                    | StatementContinue
                                                    | StatementReturn
                                                    | StatementRead
                                                    | StatementPrint
                                                    | StatementBlock;

                            StatementDesignator ::= DesignatorStatement SEMICOLON;

                                    StatementIf ::= IF PARENTHESES_LEFT Condition PARENTHESES_RIGHT Statement
                                                    | IF PARENTHESES_LEFT Condition PARENTHESES_RIGHT Statement
                                                    ELSE Statement;

                                   StatementFor ::= FOR PARENTHESES_LEFT
                                                    OptionalDesignatorStatement SEMICOLON
                                                    OptionalCondition SEMICOLON
                                                    OptionalDesignatorStatement SEMICOLON
                                                    PARENTHESES_RIGHT Statement;

                                 StatementBreak ::= BREAK SEMICOLON;

                              StatementContinue ::= CONTINUE SEMICOLON;

                                StatementReturn ::= RETURN SEMICOLON
                                                    | RETURN Expression SEMICOLON;

                                  StatementRead ::= READ PARENTHESES_LEFT Designator PARENTHESES_RIGHT SEMICOLON;

                                 StatementPrint ::= PRINT PARENTHESES_LEFT Expression PARENTHESES_RIGHT;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                         DESIGNATOR STATEMENT
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                    OptionalDesignatorStatement ::= DesignatorStatement
                                                    | /* epsilon */;

                            DesignatorStatement ::= VOID VOID VOID SEMICOLON;

                                     Designator ::= VOID VOID SEMICOLON;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                                    CONDITION
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                              OptionalCondition ::= Condition
                                                    | /* epsilon */;

                                      Condition ::= VOID VOID VOID VOID SEMICOLON;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//                                        OTHER
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Expression ::= VOID VOID VOID VOID VOID SEMICOLON;

